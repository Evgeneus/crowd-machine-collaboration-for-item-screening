import numpy as np
from scipy.stats import beta

from src.screening_algorithms.helpers.utils import compute_metrics


def generate_vote(gt, acc, corr, vote_prev):
    if np.random.binomial(1, corr, 1)[0]:
        vote = vote_prev
    else:
        if np.random.binomial(1, acc):
            vote = gt
        else:
            vote = 1 - gt
    return vote


# fuse votes via weighted majority voting
# output_data: probabilities to be negatives for each filter and item
def naive_bayes(votes_list, filters_num, items_num, estimated_acc):
    probs_list = [None]*filters_num*items_num
    for filter_index in range(filters_num):
        filter_machines_acc = estimated_acc
        for item_index in range(items_num):
            like_true_val = 1  # assume true value is positive
            a, b = 1., 1.  # constituents of baysian formula, prior is uniform dist.
            # a responds for positives, b - for negatives
            for vote, acc in zip(votes_list[item_index*filters_num + filter_index], filter_machines_acc):
                if vote == like_true_val:
                    a *= acc
                    b *= 1 - acc
                else:
                    a *= 1 - acc
                    b *= acc
            probs_list[item_index*filters_num + filter_index] = b / (a + b)
    return probs_list


def classify_items(ensembled_votes, filters_num, items_num):
    items_labels = []
    neg_thr = 0.99  # threshold to classify as a positive
    for item_index in range(items_num):
        prob_filters_not_apply = 1.
        for filter_index in range(filters_num):
            prob_filters_not_apply *= ensembled_votes[item_index*filters_num + filter_index]
        prob_item_out = 1. - prob_filters_not_apply

        # classify item
        if prob_item_out > neg_thr:
            items_labels.append(0)
        else:
            items_labels.append(1)
    return items_labels


def get_machines(corr, machine_tests, select_conf):
    machines_num = 10
    test_votes = [[] for _ in range(machines_num)]

    # generate accuracy of machines
    machines_acc = np.random.uniform(0.5, 0.95, machines_num)
    first_machine_acc = machines_acc[0]

    # set votes on tests that are generated by first machine
    test_votes[0] = list(np.random.binomial(1, first_machine_acc, machine_tests))

    # generate votes for the rest machines to be tested
    for m_id, acc in enumerate(machines_acc[1:]):
        for i in range(machine_tests):
            if np.random.binomial(1, corr):
                vote = test_votes[0][i]
            else:
                vote = np.random.binomial(1, acc)
            test_votes[m_id+1].append(vote)

    selected_machines_acc = []
    estimated_acc = []
    for machine_votes, acc in zip(test_votes, machines_acc):
        correct_votes_num = sum(machine_votes)
        conf = beta.sf(0.5, correct_votes_num+1, machine_tests-correct_votes_num+1)
        if conf > select_conf:
            selected_machines_acc.append(acc)
            m_acc = correct_votes_num / machine_tests
            if m_acc > 0.95:
                m_acc = 0.95
            estimated_acc.append(m_acc)

    # check number of machines passed tests
    # add at least one machine passed tests (accuracy in [0.55, 0.9])
    if len(selected_machines_acc) < 1:
        print('zero')
        m_acc = np.random.uniform(0.55, 0.9)
        selected_machines_acc.append(m_acc)
        estimated_acc.append(m_acc)

    return selected_machines_acc, estimated_acc


def machine_ensemble(params):
    filters_num = params['filters_num']
    items_num = params['items_num']
    ground_truth = params['ground_truth']
    lr = params['lr']
    corr = params['corr']
    machine_tests = params['machine_tests']
    select_conf = params['select_conf']
    
    machines_accuracy, estimated_acc = get_machines(corr, machine_tests, select_conf)

    votes_list = [[] for _ in range(items_num*filters_num)]

    # generate votes for the first machine
    first_machine_acc = machines_accuracy[0]
    for item_index in range(items_num):
        for filter_index in range(filters_num):
            gt = ground_truth[item_index*filters_num + filter_index]  # can be either 0 or 1
            if np.random.binomial(1, first_machine_acc):
                vote = gt
            else:
                vote = 1 - gt
            votes_list[item_index * filters_num + filter_index].append(vote)

    # generate votes for the rest machines
    rest_machine_acc = machines_accuracy[1:]
    for item_index in range(items_num):
        for filter_index in range(filters_num):
            gt = ground_truth[item_index*filters_num + filter_index]  # can be either 0 or 1
            vote_prev = votes_list[item_index*filters_num + filter_index][0]
            for machine_acc in rest_machine_acc:
                vote = generate_vote(gt, machine_acc, corr, vote_prev)
                votes_list[item_index*filters_num + filter_index].append(vote)

    # ensemble votes for each filter and item
    ensembled_votes = naive_bayes(votes_list, filters_num, items_num, estimated_acc)

    items_labels = classify_items(ensembled_votes, filters_num, items_num)
    loss, recall, precision, f_beta, _ = compute_metrics(items_labels, ground_truth, lr, filters_num)
    return loss, recall, precision, f_beta, ensembled_votes

